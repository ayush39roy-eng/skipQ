
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { requireRole } from '@/lib/session'
import crypto from 'crypto'

export const dynamic = 'force-dynamic'

export async function POST(req: Request) {
  try {
    const session = await requireRole(['USER'])
    if (!session) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

    const body = await req.json()
    const { paymentIntentId, razorpayPaymentId, razorpayOrderId, razorpaySignature } = body

    if (!paymentIntentId) return NextResponse.json({ error: 'Missing PaymentIntent ID' }, { status: 400 })

    // @ts-ignore - Stale Prisma types in editor
    const intent = await prisma.paymentIntent.findUnique({
      where: { id: paymentIntentId },
      include: { order: { include: { payment: true, items: { include: { menuItem: true } } } } }
    })

    if (!intent) return NextResponse.json({ error: 'Invalid PaymentIntent' }, { status: 404 })
    if (intent.userId !== session.userId) return NextResponse.json({ error: 'Unauthorized intent' }, { status: 403 })

    // IDEMPOTENCY CHECK
    if (intent.status === 'SUCCEEDED' && intent.order) {
        return NextResponse.json(intent.order)
    }

    // PAYMENT VERIFICATION
    let isVerified = false
    
    // 1. Simulation Check (Dev Only)
    if (razorpayPaymentId?.startsWith('pay_simulated_')) {
        if (process.env.NODE_ENV !== 'development') {
             return NextResponse.json({ error: 'Simulation not allowed in production' }, { status: 403 })
        }
        isVerified = true
    } 
    // 2. Razorpay Signature Verification
    else if (process.env.RAZORPAY_KEY_SECRET && razorpayOrderId && razorpayPaymentId && razorpaySignature) {
        const generatedSignature = crypto
            .createHmac('sha256', process.env.RAZORPAY_KEY_SECRET)
            .update(razorpayOrderId + '|' + razorpayPaymentId)
            .digest('hex')
            
        if (generatedSignature === razorpaySignature) {
            isVerified = true
        } else {
            console.error('Signature mismatch', { generatedSignature, razorpaySignature })
        }
    }
    // 3. Fallback: Fetch Status (omitted for brevity, assume signature is primary)
    
    if (!isVerified) {
        return NextResponse.json({ error: 'Payment verification failed' }, { status: 400 })
    }

    // CREATE ORDER FROM SNAPSHOT
    const snapshots = intent.itemsSnapshot as any[]
    const locData = intent.locationData as any || {}

    // Calculate aggregate totals from snapshot to be safe (or use intent.amountCents)
    // We trust snapshot because it was generated by our backend in step 1
    const subtotalCents = snapshots.reduce((sum, item) => sum + (item.priceCents * item.quantity), 0)
    const taxCents = snapshots.reduce((sum, item) => sum + (item.taxAmountCents * item.quantity), 0)
    // Re-calculate platform fee logic or infer? 
    // Actually, total = sub + tax + fee.
    // fee = total - sub - tax
    const platformFeeAmount = intent.amountCents - subtotalCents - taxCents
    
    const order = await prisma.$transaction(async (tx) => {
        // 1. Create Order
        const newOrder = await tx.order.create({
            data: {
                idempotencyKey: intent.id, // Use Intent ID as idempotency key to prevent dupes and null-collisions
                userId: session.userId,
                canteenId: intent.canteenId,
                items: {
                    create: snapshots.map((item) => ({
                        menuItemId: item.menuItemId,
                        quantity: item.quantity,
                        priceCents: item.priceCents,
                        taxRate: item.taxRate,
                        taxAmountCents: item.taxAmountCents,
                        totalCents: item.totalCents,
                        modifiersSnapshot: item.modifiersSnapshot
                    }))
                },
                fulfillmentType: intent.fulfillmentType || 'TAKEAWAY',
                status: 'PENDING', // Confirmed but kitchen hasn't accepted yet
                source: 'ONLINE',
                
                // Financials
                subtotalCents,
                taxCents,
                totalCents: intent.amountCents,
                commissionCents: platformFeeAmount,
                vendorTakeCents: subtotalCents + taxCents,
                platformFeeAmount: platformFeeAmount,
                
                // Location / Meta
                selectedOrderType: locData.selectedOrderType,
                orderType: locData.finalOrderType,
                autoConverted: locData.autoConverted,
                autoConversionReason: locData.autoConversionReason,
                distanceFromVendorMeters: locData.distanceFromVendorMeters,
                userLatitude: locData.userLatitude,
                userLongitude: locData.userLongitude,
                locationAccuracy: locData.locationAccuracy,
                cookingInstructions: locData.cookingInstructions,
                
                // @ts-ignore - Prisma types update pending
                paymentIntentId: intent.id
            }
        })

        // 2. Create Payment Record
        await tx.payment.create({
            data: {
                orderId: newOrder.id,
                amountCents: intent.amountCents,
                provider: 'razorpay',
                externalOrderId: razorpayOrderId || intent.paymentProviderOrderId,
                status: 'SUCCESS',
                paidAt: new Date()
            }
        })

        // 3. Update Intent
        // @ts-ignore - Stale Prisma types in editor
        await tx.paymentIntent.update({
            where: { id: intent.id },
            data: { 
                status: 'SUCCEEDED',
                // orderId is now handled by the Order holding the foreign key
            }
        })
        
        return newOrder
    })
    
    return NextResponse.json(order)

  } catch (error: any) {
    console.error('Finalize PaymentIntent Error:', error)
    return NextResponse.json({ error: error.message || 'Internal Server Error' }, { status: 500 })
  }
}
